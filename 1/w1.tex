\documentclass[12pt,letterpaper]{article}

\usepackage{quiver}
\usepackage{Pack}
\usepackage{PackMath}
\usepackage[placement=bottom,angle=0,color=black!40,scale=3,hshift=88,vshift=5]{background}
\usepackage{enumitem}
\setlist{nosep}
\usepackage{hyperref}
\usepackage{cleveref}


\usepackage{minted}
\newcommand{\code}[1]{\texttt{#1}}
% \newenvironment{codeblock}{\VerbatimEnvironment \begin{minted}[linenos,breaklines]{python}}{\end{minted}}


\backgroundsetup{contents={-\thepage-}}
\makeatletter
\renewcommand*\env@matrix[1][*\c@MaxMatrixCols c]{%
   \hskip -\arraycolsep
   \let\@ifnextchar\new@ifnextchar
   \array{#1}}
\makeatother

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[LE,RO]{Workshop 1}
\fancyhead[CE,CO]{Jaden Long}
\fancyhead[RE,LO]{Duke BioByte}
%\fancyfoot[CE,CO]{}

% For progress tracker
\newcommand{\ns}{{\color{red} Not Started}}
\newcommand{\ip}{{\color{orange} In Progress (Stuck)}}
\newcommand{\td}{{\color{blue} In Progress (To-Do)}}
\newcommand{\fin}{{\color{green} Finished}}
\newcommand{\qm}{{\color{violet} Finshed, But In Doubt}}
\newcommand{\contradiction}{\Rightarrow\!\Leftarrow}
\renewcommand{\im}{\mathrm{im\,}}
\renewcommand{\tilde}{\widetilde}
\setlength{\parindent}{0em}
\setlength{\parskip}{0.5em}


\usepackage{notomath}
\usepackage{multicol}
\newcommand{\Hint}{\textcolor{violet}{\textit{Hint: }}}
\newcommand{\Solution}{\textcolor{MidnightBlue}{\textbf{Solution: }}}


\title{\textbf{Talking to a Computer: Fundamentals of the Command Line}}
\author{\textit{Computational Tools for the Working Biologist. Workshop 1}}
\date{Jaden Long}

\begin{document}
\maketitle
\thispagestyle{empty}

\vspace{1em}

\noindent
You heard about this great software tool, but you have no idea where to type all the monospaced text that appears in its tutorial. Let's solve that.

\noindent
\textbf{Central idea/technique:} Being able to run software from source code

\textbf{Practice:}

\begin{itemize}
   \item Basics of command line: terminal, man, package manager, text editor
   \item Running softwares: git, GitHub, make, readme
   \item Command line scripting*: shebang, variables, command substitution, redirection, piping, awk, grep
\end{itemize}

\section{Getting started}

% The popular desktop operating systems can be roughly characterized into three major categories: Windows, MacOS, and Linux. Collectively, MacOS and Linux are called ``*NIX''\footnote{The interested audience can read up on the history of operating systems.}.

Most softwares assume a *NIX operating system. That is, MacOS or Linux. We will do the same for this workshop. Following we will go over how to open the terminal. This is the only section where instructions differ for audience of different operating systems.

\begin{itemize}
   \item Windows users should install the latest version of \href{https://learn.microsoft.com/en-us/windows/wsl/install}{Windows Subsystem for Linux (WSL)}. \href{https://apps.microsoft.com/detail/9N0DX20HK701?hl=en-US&gl=US}{Windows Terminal} should also be nice, but takes a while to set up.
   \item MacOS users have a built-in terminal which can be found in the folder \textit{Applications/Utilities} or via searching by spotlight.
   \item Linux users can open their terminal by Ctrl+Alt+T.
\end{itemize}

Open up the command line, type \texttt{ls -l /}, and hit \texttt{<enter>}, you should see something like this:


\begin{minted}[breaklines]{bash}
$ ls -l /
total 100
lrwxrwxrwx   1 root root     7 Sep 29  2022 bin -> usr/bin
drwxr-xr-x   4 root root  4096 Dec 26 08:29 boot
drwxrwxr-x   2 root root  4096 Mar  1  2021 cdrom
drwxr-xr-x  21 root root  6240 Dec 26 08:26 dev
drwxrwxr-x 195 root root 12288 Dec 26 08:29 etc
drwxr-xr-x   4 root root  4096 Feb  4  2022 home

<Many more lines omitted>
\end{minted}

Congratulations, you just ran your first shell command!

\section{Commands}

Let's recap this command \texttt{ls -l /} more closely. It has three parts, separated by spaces: \texttt{ls}, \texttt{-l}, and \texttt{/}. The first part (\texttt{ls}) is the \textit{executable}, and the parts that follow (\texttt{-l /}) are the \textit{parameters}.

\subsection{The Executable}

\texttt{ls} is the executable program. It is just like an application you open on your computer, such as Google Chrome, except that this program is executed in the terminal.

Your operating system has search paths for executables. Run the command \texttt{echo \$PATH} to see them: Mine looks like

\begin{minted}[breaklines,breakanywhere]{bash}
$ echo $PATH
/home/longyuxi/.poetry/bin:/home/longyuxi/bin:/home/longyuxi/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/home/longyuxi/bin:/home/longyuxi/java/jdk-19.0.2/bin ...
\end{minted}

This produces a list of folders separated by colons. When you run the \texttt{ls} command in the shell, your operating system looks at each of these folders and see if the \texttt{ls} executable is in that folder, and executes the first \texttt{ls} executable it finds. To find exactly which \texttt{ls} you just executed, invoke the command

\begin{minted}[breaklines]{bash}
$ which ls
/usr/bin/ls
\end{minted}

This tells us the \texttt{ls} executable we used is located at \texttt{/usr/bin/ls}. When executing an executable, we can also use its path (\cref*{sec:path}) to execute it. In other words, the command \texttt{/usr/bin/ls -l /} is equivalent to \texttt{ls -l /}.

The audience interested in what \texttt{\$PATH} is can read more about \textit{environment variables}.

\subsection{The Parameters} \label{sec:parameters}

To find what parameters a command takes, one can usually call the command with the \texttt{-{}-help} parameter. For example,

\begin{minted}[breaklines]{text}
$ ls --help
Usage: ls [OPTION]... [FILE]...
List information about the FILEs (the current directory by default).
Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.

Mandatory arguments to long options are mandatory for short options too.
  -a, --all                  do not ignore entries starting with .
  -A, --almost-all           do not list implied . and ..
      --author               with -l, print the author of each file
  -b, --escape               print C-style escapes for nongraphic characters
      --block-size=SIZE      with -l, scale sizes by SIZE when printing them;
                               e.g., '--block-size=M'; see SIZE format below
  -B, --ignore-backups       do not list implied entries ending with ~
  -c                         with -lt: sort by, and show, ctime (time of last
                               modification of file status information);
                               with -l: show ctime and sort by name;
                               otherwise: sort by ctime, newest first
...
\end{minted}

A more standard way is to call \texttt{man <command>}, where \texttt{man} stands for ``manual''. For example,

\begin{minted}[breaklines]{text}
$ man ls
LS(1)                                                  User Commands                                                  LS(1)

NAME
       ls - list directory contents

SYNOPSIS
       ls [OPTION]... [FILE]...

DESCRIPTION
       List  information about the FILEs (the current directory by default).  Sort entries alphabetically if none of -cftu‚Äê
       vSUX nor --sort is specified.

       Mandatory arguments to long options are mandatory for short options too.

       -a, --all
              do not ignore entries starting with .

       -A, --almost-all
              do not list implied . and ..

       --author
              with -l, print the author of each file

       -b, --escape
              print C-style escapes for nongraphic characters

       --block-size=SIZE
              with -l, scale sizes by SIZE when printing them; e.g., '--block-size=M'; see SIZE format below

...
\end{minted}

Note that in \texttt{man <command>}, the output is displayed with \texttt{less}, which is a very convenient command-line viewer for large texts. Use the keys \texttt{j} and \texttt{k} to navigate down or up, and \texttt{q} to quit. Its most commonly used controls can be found widely on the Internet (e.g., \href{https://linuxize.com/post/less-command-in-linux/#less-commands}{here}). and of course, you can run \texttt{man less} to view the manual of \texttt{less}.

Each parameter begins with a single or double dash and can be chained together. For example, if I want to list the files

\begin{itemize}
   \item In a long format (\texttt{-l});
   \item In a human-readable format (\texttt{-h});
   \item Sorted by time (\texttt{-t});
   \item In reverse order (\texttt{-r}),
\end{itemize}

I can run the command \texttt{ls -lhtr}, which is equivalent to \texttt{ls -l -h -t -r}.

Often there are single letter and full word versions of the same parameter, where the single letter version is prefixed with a single dash and the full word version is prefixed with a double dash. For example, \texttt{-a} and \texttt{-{}-all} are equivalent. Finally, some parameters allow you to specify an additional value with that parameter (e.g., \texttt{--block-size=SIZE}, where you can change the \texttt{SIZE} part to a value for your purposes).

\subsection{The Path} \label{sec:path}

Recapitulating, we saw that \texttt{ls} takes \texttt{[OPTION]} and \texttt{[FILE]}. We have dealt with the \texttt{[OPTION]} part. For the \texttt{[FILE]} part, we can specify the path to a file or folder for \texttt{ls} to list. We can also not specify a directory here, so that \texttt{ls} lists files under the current directory.

Paths can be specified either relatively or absolutely.

\begin{itemize}
   \item Absolute paths start with a slash (\texttt{/}) and specify the path from the root directory. For example, in the command we executed earlier, \texttt{ls -l /}, the path \texttt{/} means we are listing the root directory.
   \item All other paths are relative paths, which means they are specified relative to the current working directory. You can find the current working directory by running the command \texttt{pwd} (print working directory).
\end{itemize}

For example, currently I have

\begin{minted}[breaklines]{bash}
$ pwd
/home/longyuxi
\end{minted}

And when I run \texttt{ls}, I see that \textit{Downloads} folder is under this directory:

\begin{minted}[breaklines]{bash}
$ ls -l
total 461776

...
drwxr-xr-x 12 longyuxi longyuxi     61440 Dec 22 15:01  Downloads
...
\end{minted}

To list my downloads folder, it is then equivalent to run either of the following commands:

\begin{itemize}
   \item \texttt{ls -l Downloads}
   \item \texttt{ls -l /home/longyuxi/Downloads}
\end{itemize}

\section{A few more things*}

Below are a few miscellaneous things before we start running softwares.

\subsection{Some important commands}

I will only give a synopsis for their purpose. Read the manual for details on how to use them.

\begin{itemize}
   \item \texttt{ls}: lists files
   \item \texttt{vim}/\texttt{emacs}/\texttt{nano}: text editor
   \item \texttt{pwd}: prints current directory
   \item \texttt{cd}: change directory
   \item \texttt{top}/\texttt{htop}/\texttt{nvtop}: CPU/GPU usage monitors
   \item \texttt{code}: if you have VS Code installed, this opens VS Code in a specified directory
   \item \texttt{df}: disk space usage
   \item \texttt{du}: disk usage of folder
   \item \texttt{less}: view text file
   \item \texttt{echo}: print out things. Useful for writing something simple to file with redirection (\cref{sec:command-line-scripting}).
   \item \texttt{rg}: search texts for string
   \item \texttt{fd}: search directory for file with name
\end{itemize}

\href{https://github.com/BurntSushi/ripgrep}{\texttt{rg}} and \href{https://github.com/sharkdp/fd}{\texttt{fd}} are not bundled with your operating system and needs to be installed manually.

\subsection{Package manager}

The easy way to install softwares is through a package manager (we will see the hard way later). Linux distributions often come with a package manager. For example, Ubuntu has \texttt{apt}. A good package manager for MacOS is \href{https://brew.sh/}{Homebrew}. Now, say we want to install the funny software \textit{cowsay}, we can look up \textit{cowsay} on the package indices of \texttt{apt} or \texttt{brew}, and install it via (on Ubuntu) \texttt{sudo apt install cowsay} or (on MacOS) \texttt{brew install cowsay}. Then you can use \texttt{cowsay} as you would with any other preinstalled software:

\begin{minted}[breaklines]{text}
$ cowsay amogus
 ________
< amogus >
 --------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||
\end{minted}

\subsection{Text editor}

It is often convenient to directly edit text files from within the command line. The most newbie-friendly command-line text editor is \texttt{nano}. For example, to write something into a file called \texttt{test.txt}, one can do

\begin{enumerate}
   \item \texttt{nano test.txt}
   \item Write something
   \item Exit and save the file by \texttt{<CTRL-X>} followed by \texttt{Y}.
\end{enumerate}

You can check that this file is indeed present by \texttt{ls -l test.txt} and \texttt{less test.txt}.

There are more efficient terminal-based text editors, such as \textit{vim} and \textit{emacs}, which take a learning curve but is worth the time.

\subsection{Command line scripting} \label{sec:command-line-scripting}

For batch processing in the command line, it is convenient to write scripts. Look up any tutorial on the Internet for details. In particular, I find the following topics to be important:

\begin{itemize}
   \item Shebang
   \item Variables
   \item Command substitution
   \item Output redirection
   \item Piping
   \item \texttt{awk} and \texttt{grep}
\end{itemize}

\subsection{File permissions}

The first column from the \texttt{ls -l} is rather important. Read \href{https://www.redhat.com/sysadmin/linux-file-permissions-explained}{this article} for details.

\section{Running softwares}

Let's install and run a software from beginning to end. Here, we emulate the scenario of 

Suppose you want to reproduce a work on genome alignment, and the paper you found indicates that it ran a software called \textit{BWA}.


\end{document}
